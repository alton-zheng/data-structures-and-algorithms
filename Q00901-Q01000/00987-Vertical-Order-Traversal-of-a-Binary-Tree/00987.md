# 987. äºŒå‰æ ‘çš„å‚åºéå†

&nbsp;

å…‰å¬é¢˜ç›®åå­—ï¼Œé¡¿æ—¶æƒ³æŠ½ã€‚ã€‚ã€‚ï¼Œ è¿˜æ˜¯ä¸èƒ½è¯´ï¼Œå“ˆå“ˆ

åˆæ˜¯äºŒå‰æ ‘ï¼Œè¿˜æ˜¯ä»€ä¹ˆå‚åºéå†ï¼Œ å‚åºéå†ï¼Œå•¥ï¼Œæ²¡å¬è¿‡ï¼Œ è¿˜æ˜¯è€è€å®å®çš„çœ‹é¢˜å§ã€‚ 

&nbsp;

## é¢˜ç›®åˆ†æ

äºŒå‰æ ‘æ ¹ root

- æŒ‰é¢˜çš„æ„æ€ï¼Œç»™æ¯ä¸ªæ ‘èŠ‚ç‚¹ï¼Œé™„åŠ äº†ä¸€ä¸ªå±æ€§å€¼ï¼Œå±æ€§åŠ æˆäº†ã€‚ é™¤äº†ç‰¹æœ‰çš„ val, è¿˜å¤šäº† $[row, col]$
- root å±æ€§ä¸º $[0, 0]$ 
- `row` å±æ€§ä¸æ ‘èŠ‚ç‚¹æ‰€åœ¨å±‚æ•°æœ‰å…³ï¼Œåœ¨ç¬¬å‡ å±‚ row å°±æ˜¯å‡ ï¼Œ ä» [0, ...) 
- `col` å±æ€§ `left` å‡ `right` åŠ 

&nbsp;

æ±‚ï¼š

- æŒ‰ `col` å€¼ç»´åº¦å‡åºè¾“å‡ºæ¯é¢—æ ‘çš„ `val` å€¼
- å€¼ä¹Ÿè¦æŒ‰ row, col ç»´åº¦ï¼Œ `val` å‡åº

&nbsp;

é¢˜ç›®è§£æå°±åˆ°è¿™é‡Œ, åˆ°æ­¤ä¸ºæ­¢ï¼Œé¢˜ç›®çš„å‚åºæ’åºæ„æ€å°±å¾ˆæ˜æœ—äº†ã€‚ 

&nbsp;

### è§£é¢˜æ€è·¯ï¼š

- æ ‘çš„é™„åŠ å±æ€§éƒ½è¦ç”¨åˆ°å¥½å¤„

- ä»é¢˜ç›®çš„æ„æ€æ¥çœ‹æ•´æ£µğŸŒ²çš„æ‰€æœ‰èŠ‚ç‚¹éƒ½éœ€è¦éå†åˆ°ï¼ŒäºŒå‰æ ‘æ²¡æœ‰æ‰€è°“çš„å‚åºéå†æ–¹æ³•ï¼Œå’±ä»¬åªèƒ½é€ é€ é€ 
- ã€ŒBFSã€ å’Œ ã€ŒDFSã€
  - ã€Œé€’å½’ã€, ã€Œè¿­ä»£ã€ï¼Œ ã€ŒMorrisã€ 

&nbsp;

ä»¥ä¸Šæ–¹æ³•éƒ½å¯ä»¥åˆ°è¾¾ç›¸åŒçš„è§£é¢˜ç›®çš„ï¼Œä½†è¿™é“é¢˜çš„é‡ç‚¹ä¸åœ¨äºé€‰æ‹©ä»€ä¹ˆæ ·çš„éå†æ–¹å¼ï¼Œè€Œåœ¨äºé€‰æ‹©ä»€ä¹ˆæ–¹æ³•æ¥å­˜å‚¨éœ€è¦æ’åºçš„å±æ€§å€¼ï¼Œåˆèƒ½æœ‰æ¯”è¾ƒå¥½çš„æ€§èƒ½ã€‚æ‰€ä»¥è¿™é“é¢˜ï¼Œéå†æ–¹æ³•å°±æ€ä¹ˆæ–¹ä¾¿æ€ä¹ˆæ¥ï¼ˆéé‡ç‚¹ï¼‰

ä¸‹é¢ä»¥ 2 ç§æ–¹æ³•æ¥å­˜å‚¨ğŸŒ²ä¿¡æ¯

&nbsp;

## æ–¹æ³•1ï¼š è‡ªå¸¦æ’åºçš„ Map + é€’å½’

```c++
class java00002.m01.Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {

        /**
         * å®šä¹‰ map æ•°æ®ç»“æ„æ¥å­˜å‚¨ä½ç½®ä¿¡æ¯
         *
         * key ä¸º col å±æ€§ï¼Œä¸ç»“æœé›†ä¸­ç»´åº¦ä¿¡æ¯ç›¸ç§°
         * åœ¨ c++ ä¸­ map ç»“æ„å·²ç»ä¸º col é»˜è®¤å‡åºäº†
         * value ä¸º
         */
        map<int, vector<pair<int, int>>> position;

        // é€’å½’ç›¸å¯¹äºè¿­ä»£ï¼ŒMorris å†™æ³•æ›´ä¼˜é›…ï¼Œè¿™é‡Œé€‰æ‹©å®ƒ
        // å¯ä»¥æ›´å¥½çš„ç†è§£è¿™é“é¢˜
        // root æ ‘ï¼Œ æŒ‰é¢˜æ„ row, col åæ ‡éƒ½ä¸º 0ï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°ä¼  postion
        dfs(root, 0, 0, position);

        // é€’å½’å®Œåï¼Œå®šä¹‰ res å˜é‡
        vector<vector<int>> res;

        // éå† postion
        for(pair<int, vector<pair<int, int>>> p: position){
            // æŒ‰ row æ’åº
            sort(p.second.begin(), p.second.end());
            vector<int> cur;
            for(const pair<int, int>& x: p.second)
                cur.push_back(x.second);
            res.push_back(cur);
        }
        return res;
    }

private:
    void dfs(TreeNode* node, int row, int col, map<int, vector<pair<int, int>>>& position){

        // èŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œæ²¡æ„ä¹‰ï¼Œç›´æ¥è¿”å›
        if(node == nullptr) {
            return;
        }

        // å°† row ï¼Œ node val ä¿¡æ¯æ·»åŠ åˆ° col ä¿¡æ¯ä¸­
        position[col].push_back({row, node->val});
        // é€’å½’éå† node left
        dfs(node->left, row + 1, col - 1,  position);
        // é€’å½’éå† node right
        dfs(node->right, row + 1, col + 1, position);
    }
};
```
```java []
class java00002.m01.Solution {
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        /**
         * å®šä¹‰ map æ•°æ®ç»“æ„æ¥å­˜å‚¨ä½ç½®ä¿¡æ¯
         *
         * key ä¸º col å±æ€§ï¼Œä¸ç»“æœé›†ä¸­ç»´åº¦ä¿¡æ¯ç›¸ç§°
         * åœ¨ c++ ä¸­ map ç»“æ„å·²ç»ä¸º col é»˜è®¤å‡åºäº†
         * åœ¨ java ä¸­ï¼Œæˆ‘ä»¬ç”¨ TreeMap æ¥ä»£æ›¿ï¼Œè¿›è¡Œè‡ªæ’åº
         * value ä¸º {row, val} å¯¹
         */
        Map<Integer, List<Integer[]>> position = new TreeMap<>();

        // é€’å½’ç›¸å¯¹äºè¿­ä»£ï¼ŒMorris å†™æ³•æ›´ä¼˜é›…ï¼Œè¿™é‡Œé€‰æ‹©å®ƒ
        // å¯ä»¥æ›´å¥½çš„ç†è§£è¿™é“é¢˜
        // root æ ‘ï¼Œ æŒ‰é¢˜æ„ row, col åæ ‡éƒ½ä¸º 0ï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°ä¼  postion
        dfs(root, 0, 0, position);

        // é€’å½’å®Œåï¼Œå®šä¹‰ res å˜é‡
        List<List<Integer>> res = new ArrayList<>();

        // éå† postion
        List<Integer> cur;
        for (List<Integer[]> l: position.values()) {
            Collections.sort(l, (a, b) -> a[0].equals(b[0]) ? a[1] - b[1] : a[0] - b[0]);
            cur = new ArrayList<>();
            for (Integer[] rowValue: l) {
                cur.add(rowValue[1]);
            }
            res.add(cur);
        }
        return res;
    }

    private void dfs(TreeNode node, int row, int col, Map<Integer, List<Integer[]>> position) {

        // èŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œæ²¡æ„ä¹‰ï¼Œç›´æ¥è¿”å›
        if (node == null) {
            return;
        }

        // å°† row ï¼Œ node val ä¿¡æ¯æ·»åŠ åˆ° col ä¿¡æ¯
        List<Integer[]> l = position.getOrDefault(col, new ArrayList<>());
        l.add(new Integer[]{row, node.val});
        position.put(col, l);

        // é€’å½’éå† node left
        dfs(node.left, row + 1, col - 1, position);
        // é€’å½’éå† node right
        dfs(node.right, row + 1, col + 1, position);
    }
}
```

&nbsp;

## æ–¹æ³•äºŒï¼š List æ’åºï¼ˆC++ vectorï¼‰

```c++
class java00002.m01.Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {

        /**
         * å®šä¹‰ vector æ•°æ®ç»“æ„æ¥å­˜å‚¨ä½ç½®ä¿¡æ¯
         * vector æœ‰ä¸ªå¾ˆå¥½çš„ç‰¹ç‚¹ï¼Œå½“å¯¹å®ƒè¿›è¡Œæ’åºæ—¶ï¼Œä¼šè€ƒè™‘åˆ°é‡Œè¾¹æ‰€æœ‰å…ƒç´ ï¼Œå‡åºéå†
         */
        vector<tuple<int, int,int>> position;

        // é€’å½’ç›¸å¯¹äºè¿­ä»£ï¼ŒMorris å†™æ³•æ›´ä¼˜é›…ï¼Œè¿™é‡Œé€‰æ‹©å®ƒ
        // å¯ä»¥æ›´å¥½çš„ç†è§£è¿™é“é¢˜
        // root æ ‘ï¼Œ æŒ‰é¢˜æ„ row, col åæ ‡éƒ½ä¸º 0ï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°ä¼  postion
        dfs(root, 0, 0, position);

        // æ’åºç»“æœ
        sort(position.begin(), position.end());

        // é€’å½’å®Œåï¼Œå®šä¹‰ res å˜é‡
        vector<vector<int>> res(abs(maxCol - minCol) + 1);

        // å› ä¸º position å·²ç»å…¨å±€æ’åºï¼Œ æŒ‰ col -> row -> val çš„ä¼˜å…ˆçº§å·²ç»æ’åºï¼Œ
        // ä¸æ–­çš„æ·»åŠ å…ƒç´ å³å¯
        for(auto& [col, row, val]: position){
            res[col - minCol].push_back(val);
        }
        return res;
    }

private:
    int minCol = 0, maxCol = 0;
    void dfs(TreeNode* node, int row, int col, vector<tuple<int, int,int>>& position){

        // èŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œæ²¡æ„ä¹‰ï¼Œç›´æ¥è¿”å›
        if(node == nullptr) {
            return;
        }

        // æ±‚æœ€å°æœ€å¤§åˆ—
        minCol = min(col, minCol);
        maxCol = max(col, maxCol);

        // æŒ‰ col, row ï¼Œval çš„é¡ºåºæ·»åŠ è¿› postion
        position.push_back({col, row, node -> val});

        // é€’å½’éå† node left
        dfs(node -> left, row + 1, col - 1,  position);
        // é€’å½’éå† node right
        dfs(node -> right, row + 1, col + 1, position);
    }
};
```
```java []
class java00002.m01.Solution {

    // å®šä¹‰ col æ•°é‡
    private int minCol = 0, maxCol = 0;
    public List<List<Integer>> verticalTraversal(TreeNode root) {

        /**
         * è¿™é‡Œç”¨ List åŒ…è£… int[] ï¼Œåœ¨æ·»åŠ å…ƒç´ å…ˆä¸è¿›è¡Œè‡ªæ’åºï¼Œæå‡æ€§èƒ½
         * æ•°ç»„ä¸­ ï¼ŒåŒ…å« {col, row, val}, ä¸é¢˜æ’åºä¼˜å…ˆçº§ä¿æŒä¸€è‡´
         * è¿™é‡Œçš„æ•°ç»„ä¹Ÿå¯ä»¥ç”¨ç±»ç»“æ„ï¼Œåœ¨ç±»ä¸­å®šä¹‰å±æ€§å’Œæ’åºè§„åˆ™
         */
        List<int[]> position = new ArrayList<>();

        // é€’å½’ç›¸å¯¹äºè¿­ä»£ï¼ŒMorris å†™æ³•æ›´ä¼˜é›…ï¼Œè¿™é‡Œé€‰æ‹©å®ƒ
        // å¯ä»¥æ›´å¥½çš„ç†è§£è¿™é“é¢˜
        // root æ ‘ï¼Œ æŒ‰é¢˜æ„ row, col åæ ‡éƒ½ä¸º 0ï¼Œ ç¬¬ä¸‰ä¸ªå‚æ•°ä¼  postion
        dfs(root, 0, 0, position);

        // æ·»åŠ å…ƒç´ åï¼Œå…ˆå¯¹ position ä½œæ•´ä½“æ’åºï¼Œcol -> row -> val
        Collections.sort(position,
                (a, b) -> a[0] == b[0] ? a[1] == b[1] ? a[2] - b[2] : a[1] - b[1] : a[0] - b[0]
        );

        // é€’å½’å®Œåï¼Œå®šä¹‰ res å˜é‡
        List<List<Integer>> res = new ArrayList<>();

        int cols = Math.abs(maxCol - minCol) + 1;
        for (int i = 1; i <= cols; i++) {
            res.add(new ArrayList<>());
        }

        // å› ä¸º position å·²ç»å…¨å±€æ’åºï¼Œ æŒ‰ col -> row -> val çš„ä¼˜å…ˆçº§å·²ç»æ’åºï¼Œ
        // ä¸æ–­çš„æ·»åŠ å…ƒç´ å³å¯
        for (int[] arr: position) {
            res.get(arr[0] - minCol).add(arr[2]);
        }
        return res;
    }

    private void dfs(TreeNode node, int row, int col, List<int[]> position) {

        // èŠ‚ç‚¹ä¸ºç©ºæ—¶ï¼Œæ²¡æ„ä¹‰ï¼Œç›´æ¥è¿”å›
        if (node == null) {
            return;
        }

        // è·å–æœ€å°çš„åˆ—æ•°
        minCol = Math.min(col, minCol);
        maxCol = Math.max(col, maxCol);

        // å°† col , row ï¼Œ node val æ„æˆæ•°ç»„æ·»åŠ åˆ° position list ä¸­
        position.add(new int[] {col, row, node.val});

        // é€’å½’éå† node left
        dfs(node.left, row + 1, col - 1, position);
        // é€’å½’éå† node right
        dfs(node.right, row + 1, col + 1, position);
    }
}
```

&nbsp;

> æ–¹æ³•äºŒæ¯”æ–¹æ³•ä¸€ï¼Œæ€§èƒ½ä¸Šæ›´ä¼˜ç§€äº›ï¼Œæ­¤é“é¢˜æœ‰å¾ˆå¤šç§æ–¹æ³•å¯ä»¥ç”¨æ¥å­˜å‚¨èŠ‚ç‚¹ä¿¡æ¯
>
> æ— å¤–ä¹ï¼Œå“ªç§ç»“æ„æ’åºæ€§èƒ½æ›´å¥½ï¼Œåœ¨è¿™é“é¢˜å°±èƒ½å–å¾—æ›´å¥½çš„ä¼˜åŠ¿ã€‚
>
> åœ¨è¿™é“é¢˜ä¸­äºŒå‰æ ‘çš„éå†æ–¹æ³•ï¼Œå°±æ˜¾å¾—ä¸é‚£ä¹ˆé‡è¦äº†ã€‚

